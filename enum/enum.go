package enum

import (
	"bytes"
	"fmt"
	"sort"
	"strconv"
	"strings"

	"github.com/carlos-yuan/cargen/util"
	"github.com/carlos-yuan/cargen/util/convert"
	"github.com/carlos-yuan/cargen/util/fileUtil"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
)

func GenEnum(path, dictTable, dictType, dictName, dictLabel, dictValue, dsn string) {
	db, _ := gorm.Open(mysql.Open(dsn))
	var dict []map[string]interface{}
	err := db.Table(dictTable).Find(&dict).Error
	if err != nil {
		println(err)
	}
	sort.Slice(dict, func(i, j int) bool {
		if dict[i] == nil && dict[j] == nil {
			istr := dict[i][dictType].(string) + dict[i][dictName].(string)
			jstr := dict[j][dictType].(string) + dict[j][dictName].(string)
			return strings.Compare(istr, jstr) == -1
		}
		return false
	})
	var buf bytes.Buffer
	buf.WriteString("// Code generated by car-gen. DO NOT EDIT.\n// Code generated by car-gen. DO NOT EDIT.\n// Code generated by car-gen. DO NOT EDIT.\npackage enum\n")
	dicts := make(map[string][]Dict)
	for _, m := range dict {
		typ := convert.ToCamelCase(strings.TrimSpace(m[dictType].(string)))
		dicts[typ] = append(dicts[typ], Dict{Type: typ, Name: convert.ToCamelCase(strings.TrimSpace(m[dictName].(string))), Label: strings.TrimSpace(m[dictLabel].(string)), Value: strings.TrimSpace(m[dictValue].(string))})
	}
	keys := util.MapToSplice(dicts)
	sort.Slice(keys, func(i, j int) bool {
		return strings.Compare(keys[i], keys[j]) == -1
	})
	for _, key := range keys {
		list := dicts[key]
		//之前类型生成代码
		var constCode, caseCode string
		for _, d := range list {
			if d.Name == "" {
				continue
			}
			val, err := strconv.ParseInt(d.Value, 10, 64)
			if err != nil {
				panic(err)
			}
			constName := d.Type + d.Name
			constCode += fmt.Sprintf(enumConstTemplate, constName, key, val)
			caseCode += fmt.Sprintf(enumCaseTemplate, constName, strings.ReplaceAll(d.Label, `"`, `\"`))
		}
		if len(caseCode) > 0 {
			caseCode = caseCode[:len(caseCode)-1]
		}
		if len(constCode) > 0 {
			constCode = constCode[:len(constCode)-1]
		}
		if len(constCode) > 0 {
			buf.WriteString(fmt.Sprintf(enumTemplate, key, constCode, key, caseCode, key, key, key, key, key, key))
		}
	}
	err = fileUtil.WriteByteFile(path+"/enum/enum.go", buf.Bytes())
	if err != nil {
		panic(err)
	}
}

type Dict struct {
	Name  string
	Type  string
	Label string
	Value string
}

const enumConstTemplate = `	%s %s= %d
`

const enumCaseTemplate = `	case %s:
		return "%s"
`

const enumTemplate = `
type %s int

const (
%s
)

func (t %s) String() string {
	switch t {
%s
	}
	return ""
}

func %sFrom[T ~int | ~int32 | ~int64](e T) *%s {
	t := %s(e)
	if t.String() == "" {
		return nil
	}
	return &t
}

func (t %s) Int() int {
	return int(t)
}

func (t %s) I32() int32 {
	return int32(t)
}

func (t %s) I64() int64 {
	return int64(t)
}
`
