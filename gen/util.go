package gen

import (
	"bytes"
	fileUtl "comm/file"
	"fmt"
	"go/ast"
	"go/doc"
	"regexp"
	"strings"
)

/**
 * 驼峰转蛇形 snake string
 * @description XxYy to xx_yy , XxYY to xx_y_y
 * @param s 需要转换的字符串
 * @return string
 **/
func ToSnakeCase(s string) string {
	data := make([]byte, 0, len(s)*2)
	j := false
	num := len(s)
	for i := 0; i < num; i++ {
		d := s[i]
		// or通过ASCII码进行大小写的转化
		// 65-90（A-Z），97-122（a-z）
		//判断如果字母为大写的A-Z就在前面拼接一个_
		if i > 0 && d >= 'A' && d <= 'Z' && j {
			data = append(data, '_')
		}
		if d != '_' {
			j = true
		}
		data = append(data, d)
	}
	//ToLower把大写字母统一转小写
	return strings.ToLower(string(data[:]))
}

/**
 * 蛇形转驼峰
 * @description xx_yy to XxYx  xx_y_y to XxYY
 * @date 2020/7/30
 * @param s要转换的字符串
 * @return string
 **/
func ToCamelCase(s string) string {
	data := make([]byte, 0, len(s))
	j := false
	k := false
	num := len(s) - 1
	for i := 0; i <= num; i++ {
		d := s[i]
		if k == false && d >= 'A' && d <= 'Z' {
			k = true
		}
		if d >= 'a' && d <= 'z' && (j || k == false) {
			d = d - 32
			j = false
			k = true
		}
		if k && d == '_' && num > i && s[i+1] >= 'a' && s[i+1] <= 'z' {
			j = true
			continue
		}
		data = append(data, d)
	}
	return string(data[:])
}

/**
 * 蛇形转驼峰
 * @description xx_yy to XxYx  xx_y_y to XxYY
 * @date 2020/7/30
 * @param s要转换的字符串
 * @return string
 **/
func ToCamelFirstLowerCase(s string) string {
	data := make([]byte, 0, len(s))
	j := false
	k := false
	num := len(s) - 1
	for i := 0; i <= num; i++ {
		d := s[i]
		if k == false && d >= 'A' && d <= 'Z' {
			k = true
		}
		if d >= 'a' && d <= 'z' && (j || k == false) {
			d = d - 32
			j = false
			k = true
		}
		if k && d == '_' && num > i && s[i+1] >= 'a' && s[i+1] <= 'z' {
			j = true
			continue
		}
		data = append(data, d)
	}
	return FistToLower(string(data[:]))
}

func FistToLower(str string) string {
	if len(str) == 0 {
		return str
	}
	word := str[0]
	if 'A' <= word && word <= 'Z' {
		word += 'a' - 'A'
	}
	byt := []byte(str)
	byt[0] = word
	return string(byt)
}

func ModelToProtobuf(path, protoPkg, goPkg, modelPath, modelName string) {
	dir, err := getImportPkg(modelPath)
	if err != nil {
		panic(err)
	}
	pkg, err := parseDir(dir, modelName)
	if err != nil {
		panic(err)
	}
	pkgs := doc.New(pkg, modelPath, doc.AllMethods)
	var protoBuf bytes.Buffer
	protoBuf.WriteString(fmt.Sprintf("// Code generated by car-gen. DO NOT EDIT.\n\nsyntax = \"proto3\";\n\npackage %s;\n\noption go_package = \"%s\";\n\n", protoPkg, goPkg))
	for _, t := range pkgs.Types {
		if strings.Contains(t.Doc, "mapped from table") && len(t.Decl.Specs) == 1 {
			list := t.Decl.Specs[0].(*ast.TypeSpec).Type.(*ast.StructType).Fields.List
			var i = 1
			protoBuf.WriteString(fmt.Sprintf("message %sRsp {\n", t.Name))
			for _, field := range list {
				name := field.Names[0].Name
				typ := ""
				switch field.Type.(type) {
				case *ast.Ident:
					typ = field.Type.(*ast.Ident).Name
				case *ast.SelectorExpr:
					typ = field.Type.(*ast.SelectorExpr).X.(*ast.Ident).Name + "." + field.Type.(*ast.SelectorExpr).Sel.Name
				case *ast.StarExpr:
					switch field.Type.(*ast.StarExpr).X.(type) {
					case *ast.Ident:
						typ = field.Type.(*ast.StarExpr).X.(*ast.Ident).Name
					case *ast.SelectorExpr:
						typ = field.Type.(*ast.StarExpr).X.(*ast.SelectorExpr).X.(*ast.Ident).Name + "." + field.Type.(*ast.StarExpr).X.(*ast.SelectorExpr).Sel.Name
					}
				}
				if !(name == "CreateBy" || name == "DeletedAt" || name == "UpdateBy") {
					if typ == "time.Time" {
						typ = "string"
					}
					switch typ {
					case "float64":
						typ = "double"
					case "float32":
						typ = "float"
					case "time.Time":
						typ = "string"
					}
					if name != "ID" {
						name = FistToLower(name)
					}
					reg := regexp.MustCompile("`gorm:(.*);comment:(.*)\"(.*)json:(.*)`")
					params := reg.FindStringSubmatch(field.Tag.Value)
					var comment string
					if len(params) == 5 {
						comment = params[2]
					} else {
						comment = name
					}
					protoBuf.WriteString(fmt.Sprintf("\t%s %s =%d;//%s\n", typ, name, i, comment))
					i++
				}
			}
			protoBuf.WriteString("}\n\n")
		}
	}
	dir = path + "\\" + protoPkg + "\\rpc\\" + protoPkg + "_model_gen.proto"
	err = fileUtl.WriteStringFile(dir, protoBuf.String())
	if err != nil {
		panic(err)
	}
}
