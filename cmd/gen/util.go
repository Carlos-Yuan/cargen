package gen

import (
	"bytes"
	"errors"
	"fmt"
	"github.com/carlos-yuan/cargen/util"
	"go/ast"
	"go/doc"
	"io"
	"os"
	"regexp"
	"strings"
	"sync"
)

func ModelToProtobuf(path, protoPkg, goPkg, modelPath, modelName string) {
	pkg, err := parseDir(modelPath, modelName)
	if err != nil {
		panic(err)
	}
	pkgs := doc.New(pkg, modelPath, doc.AllMethods)
	var protoBuf bytes.Buffer
	protoBuf.WriteString(fmt.Sprintf("// Code generated by car-gen. DO NOT EDIT.\n\nsyntax = \"proto3\";\n\npackage %s;\n\noption go_package = \"%s\";\n\n", protoPkg, goPkg))
	for _, t := range pkgs.Types {
		if strings.Contains(t.Doc, "mapped from table") && len(t.Decl.Specs) == 1 {
			list := t.Decl.Specs[0].(*ast.TypeSpec).Type.(*ast.StructType).Fields.List
			var i = 1
			protoBuf.WriteString(fmt.Sprintf("message %sRsp {\n", t.Name))
			for _, field := range list {
				name := field.Names[0].Name
				typ := ""
				switch field.Type.(type) {
				case *ast.Ident:
					typ = field.Type.(*ast.Ident).Name
				case *ast.SelectorExpr:
					typ = field.Type.(*ast.SelectorExpr).X.(*ast.Ident).Name + "." + field.Type.(*ast.SelectorExpr).Sel.Name
				case *ast.StarExpr:
					switch field.Type.(*ast.StarExpr).X.(type) {
					case *ast.Ident:
						typ = field.Type.(*ast.StarExpr).X.(*ast.Ident).Name
					case *ast.SelectorExpr:
						typ = field.Type.(*ast.StarExpr).X.(*ast.SelectorExpr).X.(*ast.Ident).Name + "." + field.Type.(*ast.StarExpr).X.(*ast.SelectorExpr).Sel.Name
					}
				}
				if !(name == "CreateBy" || name == "DeletedAt" || name == "UpdateBy") {
					if typ == "time.Time" {
						typ = "string"
					}
					switch typ {
					case "float64":
						typ = "double"
					case "float32":
						typ = "float"
					case "time.Time":
						typ = "string"
					}
					if name != "ID" {
						name = util.FistToLower(name)
					}
					reg := regexp.MustCompile("`gorm:(.*);comment:(.*)\"(.*)json:(.*)`")
					params := reg.FindStringSubmatch(field.Tag.Value)
					var comment string
					if len(params) == 5 {
						comment = params[2]
					} else {
						comment = name
					}
					protoBuf.WriteString(fmt.Sprintf("\t%s %s =%d;//%s\n", typ, name, i, comment))
					i++
				}
			}
			protoBuf.WriteString("}\n\n")
		}
	}
	dir := path + "\\" + protoPkg + "\\rpc\\" + protoPkg + "_model_gen.proto"
	err = WriteStringFile(dir, protoBuf.String())
	if err != nil {
		panic(err)
	}
}

var mutex sync.Mutex

func WriteByteFile(filePath string, data []byte) error {
	mutex.Lock()
	defer mutex.Unlock()
	fileCheck, err := os.Stat(filePath)
	if err == nil {
		if fileCheck.IsDir() {
			return errors.New("path is directory")
		}
		file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_TRUNC, 0666) //修改模式,变更为写入模式O_WRONLY和清除模式O_TRUNC
		if err != nil {
			return err
		}
		defer file.Close()
		_, err = file.Write(data)
		if err == nil {
			return err
		}
	}
	err = CreateFilePath(filePath)
	if err != nil {
		return err
	}
	file, err := os.Create(filePath)
	if err != nil {
		return err
	}
	defer file.Close()
	_, err = file.Write(data)
	return err
}

func AppendStringFile(filePath string, data string) error {
	mutex.Lock()
	defer mutex.Unlock()
	fileCheck, err := os.Stat(filePath)
	if err == nil {
		if fileCheck.IsDir() {
			return errors.New("path is directory")
		}
		file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_TRUNC, 0666) //修改模式,变更为写入模式O_WRONLY和清除模式O_TRUNC
		if err != nil {
			return err
		}
		defer file.Close()
		_, err = file.WriteString(data)
		if err == nil {
			return err
		}
	}
	err = CreateFilePath(filePath)
	if err != nil {
		return err
	}
	file, err := os.Create(filePath)
	if err != nil {
		return err
	}
	defer file.Close()
	_, err = file.WriteString(data)
	return err
}

func AppendByteFile(filePath string, data []byte) error {
	mutex.Lock()
	defer mutex.Unlock()
	fileCheck, err := os.Stat(filePath)
	if err == nil {
		if fileCheck.IsDir() {
			return errors.New("path is directory")
		}
		file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_APPEND, 0666) //修改模式,变更为写入模式O_WRONLY和清除模式O_TRUNC
		if err != nil {
			return err
		}
		defer file.Close()
		_, err = file.Write(data)
		if err == nil {
			return err
		}
	}
	err = CreateFilePath(filePath)
	if err != nil {
		return err
	}
	file, err := os.Create(filePath)
	if err != nil {
		return err
	}
	defer file.Close()
	_, err = file.Write(data)
	return err
}

func WriteStringFile(filePath string, data string) error {
	mutex.Lock()
	defer mutex.Unlock()
	fileCheck, err := os.Stat(filePath)
	if err == nil {
		if fileCheck.IsDir() {
			return errors.New("path is directory")
		}
		file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_TRUNC, 0666) //修改模式,变更为写入模式O_WRONLY和清除模式O_TRUNC
		if err != nil {
			return err
		}
		defer file.Close()
		_, err = file.WriteString(data)
		if err == nil {
			return err
		}
	}
	err = CreateFilePath(filePath)
	if err != nil {
		return err
	}
	file, err := os.Create(filePath)
	if err != nil {
		return err
	}
	defer file.Close()
	_, err = file.WriteString(data)
	return err
}

func CreateFilePath(path string) error {
	if !IsFile(path) {
		path = strings.Replace(path, "\\", "/", -1)
		path = path[:strings.LastIndex(path, "/")]
		if !IsExist(path) {
			err := os.MkdirAll(path, os.ModePerm)
			if err != nil {
				return err
			}
		}
	} else {
		return errors.New("path is file")
	}
	return nil
}

func IsExist(f string) bool {
	_, err := os.Stat(f)
	boolean := os.IsExist(err)
	return err == nil || boolean
}

func IsFile(f string) bool {
	fi, e := os.Stat(f)
	if e != nil {
		return false
	}
	return !fi.IsDir()
}

func ReadAll(filePth string) ([]byte, error) {
	f, err := os.Open(filePth)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	return io.ReadAll(f)
}
